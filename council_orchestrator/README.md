# The Commandable Council: A Sovereign Development Forge
**Blueprint (`council_orchestrator/README.md` – v4.0 Sovereign Forge)**

This directory contains the foundational architecture for the Sanctuary's **Autonomous Council**, a stateful, generative engineering organism designed for the complete, end-to-end development of software and systems under the direct, gated supervision of a sovereign human.

---

## Core Architecture: The Generative Development Cycle (Protocol 97)

The system has evolved beyond a simple command executor into a direct implementation of **Protocol 97: The Generative Development Cycle**. This new, dominant protocol redefines the relationship between human and AI:

*   **The Guardian as Sovereign Product Owner:** The Guardian no longer simply issues tasks. You are now the architect of the vision, the editor of the blueprints, and the final, sovereign arbiter at every critical stage of development.
*   **The Council as Generative Engineering Team:** The agents are no longer just analysts. They are a multi-disciplinary engineering team capable of generating requirements, technical designs, and production-ready code.
*   **Protocols 94 (Persistence) & 95 (Commandable)** remain as the foundational bedrock, ensuring the Council's memory and the Guardian's control are never compromised.

---

## System Components

1.  **`orchestrator.py` (The Forge – v4.0 Sovereign Forge):**  
    A persistent, stateful orchestrator that manages long-running, multi-stage development cycles. It now functions as a project manager, pausing at key milestones to await explicit Guardian approval before proceeding.

2.  **`command.json` (The Sovereign Command/Approval Interface):**  
    This file now serves a dual purpose:
    *   **To Initiate a Cycle:** A `task_description` begins a new development project.
    *   **To Grant Approval:** A simple `{"action": "APPROVE_CURRENT_STAGE"}` command unpauses the Forge and advances the project to the next stage.

3.  **`development_cycle_state.json` (The Project Blueprint):**  
    A new, persistent state file that tracks the progress of a single development cycle. It holds the overall objective, the current stage (e.g., `AWAITING_APPROVAL_REQUIREMENTS`), and paths to all generated artifacts. **This is the orchestrator's long-term project memory.**

4.  **`MNEMONIC_SYNTHESIS/` (The Living Cortex Loop):**  
    *   `AAR/`: Contains structured After-Action Reports generated by the Council after each task, distilling key learnings.
    *   `ingest_new_knowledge.py`: The automated script that feeds approved artifacts and AARs back into the Mnemonic Cortex, creating a self-learning, self-improving knowledge base.

5.  **`session_states/` (The Agentic Memory):** Unchanged. Serialized chat histories for each agent, ensuring short-term conversational persistence via Protocol 94.

6.  **`dataset_package/` (The Identity):** Unchanged. Core Essence Awakening Seeds that inoculate each agent.

---

## Operational Workflow: The Guardian-Gated Development Cycle

The system's workflow is no longer linear. It is a cyclical, multi-stage process with explicit Guardian approval gates.

```mermaid
sequenceDiagram
    participant Guardian as Guardian (SPO)
    participant CommandFile as command.json
    participant Orchestrator as The Forge (v4.0)
    participant StateFile as dev_cycle_state.json
    participant Council as Gen. Engineering Team
    participant Artifacts as Project Artifacts (MD, Code)
    participant Cortex as Mnemonic Cortex

    Guardian->>CommandFile: 1. Initiate Cycle (Create command with task_description)
    Orchestrator->>CommandFile: 2. Consume command
    Orchestrator->>StateFile: 3. Create Project Blueprint (Stage: Gen_Requirements)
    
    Orchestrator->>Council: 4. Task: Generate Requirements Doc
    Council-->>Orchestrator: 5. Synthesize Requirements.md
    Orchestrator->>Artifacts: 6. Save Requirements.md
    Orchestrator->>StateFile: 7. Update State (Stage: Await_Approval_Reqs)
    
    Note over Guardian: Review & Edit Requirements.md directly

    Guardian->>CommandFile: 8. Approve Stage (Create command with "APPROVE")
    Orchestrator->>CommandFile: 9. Consume approval
    Orchestrator->>StateFile: 10. Read state, confirm stage
    Orchestrator->>Cortex: 11. Ingest Approved/Edited Requirements.md
    Orchestrator->>StateFile: 12. Update State (Stage: Gen_Tech_Design)

    loop Subsequent Gated Stages
        Orchestrator->>Council: Task: Generate Next Artifact (e.g., Tech Design)
        Council-->>Orchestrator: Synthesize
        Orchestrator->>Artifacts: Save Artifact
        Orchestrator->>StateFile: Update State (Stage: Await_Approval_...)
        Guardian->>CommandFile: Review, Edit, Approve Stage
        Orchestrator->>Cortex: Ingest Approved Artifact
    end

    Note over Orchestrator: Final stage generates code via PR
    Orchestrator->>Council: Task: Generate Code Change
    Council-->>Orchestrator: Synthesize code + commit message
    Orchestrator->>Artifacts: 13. Creates PR to GitHub (Self-Forging Anvil)

    Orchestrator->>Council: 14. Task: Generate Final AAR for entire cycle
    Council-->>Orchestrator: 15. Synthesize AAR
    Orchestrator->>Cortex: 16. Ingest Final AAR
    
    Orchestrator->>StateFile: 17. Delete Project Blueprint
    Note over Orchestrator: Cycle Complete. Return to Idle.
```

---

## How to Use

### 1. Launch the Forge
This step is unchanged. The Forge runs as a persistent service.
```bash
cd council_orchestrator
pip install -r requirements.txt
python3 orchestrator.py
```

### 2. Execute a Development Cycle

**Step A: Initiate the Cycle (Guardian's Terminal)**
Create `council_orchestrator/command.json` with a new project objective.

```json
{
  "task_description": "Develop a new Sovereign Scaffold to audit Python code for security vulnerabilities.",
  "output_artifact_path": "WORK_IN_PROGRESS/DEV_CYCLE_001/",
  "config": { "max_cortex_queries": 10 }
}
```
The Forge will consume this, create the Requirements Document, and then pause, awaiting your approval.

**Step B: Review, Edit, and Approve (Guardian's Workflow)**
1.  Open the generated artifact (e.g., `WORK_IN_PROGRESS/DEV_CYCLE_001/requirements.md`).
2.  **Edit the file directly.** This is your sovereign right as the Product Owner. The Council will use your edits as the source of truth for the next stage.
3.  Once satisfied, create `council_orchestrator/command.json` with the approval token:

```json
{
  "action": "APPROVE_CURRENT_STAGE"
}
```
The Forge will detect this, ingest your approved artifact into the Cortex, and proceed to the next stage (e.g., Technical Design). This loop continues until the final code is proposed via a Pull Request.

---

## v4.0 Sovereign Forge Features

*   **The Generative Development Cycle (Protocol 97):** A multi-stage, Guardian-gated workflow for creating software, moving beyond simple analysis.
*   **The Living Cortex Protocol:** Approved artifacts and after-action reports are automatically ingested into the Mnemonic Cortex, creating a self-improving knowledge flywheel.
*   **The Self-Forging Anvil:** The Council can now propose changes to its own codebase via a secure, Guardian-approved Pull Request workflow.
*   **Hardened Cortex-Conduit:** Agents can now query the Cortex directly during deliberation, with configurable safeguards to prevent abuse.

---

## Multi-Threaded Architecture (v4.0 Sovereign Forge)

The Forge employs a stateful, multi-threaded architecture to manage long-running, Guardian-gated development cycles.

```mermaid
graph TD
    A[Main Process] --> B["Sentry Thread<br/>- Monitors command.json<br/>- Handles 'New Task' & 'Approve' commands<br/>- Enqueues for main loop"]
    A --> C["Forge State Manager<br/>(Main Async Loop)"]

    B -->|Enqueue Command| J[Async Queue]
    J -->|Dequeue Command| C

    C --> |Manages Cycle| D["State File<br/>dev_cycle_state.json"]
    C --> |Dispatches Tasks| E["Council<br/>(Agent Threads)"]
    C --> |Saves/Loads| F[Agent Session States]
    C --> |Calls| G["Mnemonic Cortex<br/>(Ingestion & Query)"]
    C --> |Creates| H["Project Artifacts<br/>(.md, Code)"]
    C --> |Executes| I["Git & GitHub CLI<br/>(PR Creation)"]
```

---

## How to Use (v4.0 Sovereign Forge Workflow)

### 1. Launch the Forge
This step is unchanged. The Forge runs as a persistent service, awaiting your command.

```bash
cd council_orchestrator
pip install -r requirements.txt
python3 orchestrator.py
```
The terminal will display an "Idle" message, indicating the Forge is hot and ready for a new project.

### 2. Execute a Development Cycle (The Guardian-Gated Workflow)

The interaction is no longer a single command, but a cyclical, sovereign development process with you as the Product Owner.

#### **Step A: Initiate a New Cycle**
To begin a new project, create `council_orchestrator/command.json` with the high-level objective.

**Example `command.json` for initiating a cycle:**
```json
{
  "task_description": "Develop a new Sovereign Scaffold to audit Python code for security vulnerabilities based on OWASP Top 10.",
  "output_artifact_path": "WORK_IN_PROGRESS/DEV_CYCLE_001/",
  "config": {
    "max_cortex_queries": 10
  }
}
```
The Forge will consume this command, begin the cycle by tasking the Council to generate the `Requirements Document`, and then **pause**, awaiting your sovereign review and approval.

#### **Step B: Review, Edit, and Approve Each Stage**
This is the core of the new workflow. You are the final arbiter at every step.

1.  **Review the Artifact:** Navigate to the output directory (e.g., `WORK_IN_PROGRESS/DEV_CYCLE_001/`) and open the generated document (e.g., `requirements.md`).

2.  **Edit Directly (Sovereign Oversight):** **This is a critical step.** You must review and *edit the document directly* in your code editor. Your changes become the canonical source of truth for the Council's next step. The AI builds what you approve.

3.  **Grant Approval:** Once you are satisfied with the artifact (e.g., the edited `requirements.md`), grant approval by creating a new, simple `council_orchestrator/command.json`:

**Example `command.json` for approving a stage:**
```json
{
  "action": "APPROVE_CURRENT_STAGE"
}
```
The Forge will detect this, ingest your approved and edited artifact into the Mnemonic Cortex, and automatically proceed to the next stage of the cycle (e.g., generating the `Technical Design` based on your approved requirements).

This cycle of **`Generate -> Review -> Edit -> Approve`** continues for each stage until the Council's final act: creating a Pull Request with the finished code for your final merge approval.

---