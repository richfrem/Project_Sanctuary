#!/usr/bin/env python3
"""
Plugin Orphan Cleaner
=====================

Scans agent directories for artifacts belonging to plugins that no longer exist
in the source `plugins/` directory.

Target Directories:
- .agent/workflows, .agent/skills, .agent/rules
- .github/prompts, .github/skills, .github/rules
- .gemini/commands, .gemini/skills, .gemini/rules
- .claude/commands, .claude/skills, .claude/rules

Usage:
  python3 plugins/plugin-manager/scripts/clean_orphans.py [--dry-run]
"""

import os
import sys
import shutil
import argparse
from pathlib import Path

# --- Configuration ---

AGENT_DIRS = {
    "antigravity": [
        ".agent/workflows",
        ".agent/skills",
        ".agent/rules"
    ],
    "github": [
        ".github/prompts",
        ".github/skills",
        ".github/rules"
    ],
    "gemini": [
        ".gemini/commands",
        ".gemini/skills",
        ".gemini/rules"
    ],
    "claude": [
        ".claude/commands",
        ".claude/skills",
        ".claude/rules"
    ]
}

def get_active_plugins(root: Path):
    """Returns a set of active plugin names from the plugins/ directory."""
    plugins_dir = root / "plugins"
    if not plugins_dir.exists():
        print(f"Error: Plugins directory not found at {plugins_dir}")
        sys.exit(1)
    
    active_plugins = set()
    for item in plugins_dir.iterdir():
        if item.is_dir():
            # Check for manifest name override, otherwise use dir name
            manifest = item / ".claude-plugin" / "plugin.json"
            if manifest.exists():
                try:
                    import json
                    data = json.loads(manifest.read_text(encoding='utf-8'))
                    name = data.get("name", item.name)
                    active_plugins.add(name)
                except:
                    active_plugins.add(item.name)
            else:
                active_plugins.add(item.name)
    
    return active_plugins

def clean_directory(target_dir: Path, active_plugins: set, dry_run: bool):
    """Scans a directory and removes items not belonging to active plugins."""
    if not target_dir.exists():
        return

    print(f"Scanning {target_dir}...")
    
    for item in target_dir.iterdir():
        is_orphan = False
        owner_plugin = None

        # Heuristic 1: Directories (Skills/Rules usually named exactly as plugin_name)
        if item.is_dir():
            if item.name not in active_plugins:
                is_orphan = True
                owner_plugin = item.name # Best guess
        
        # Heuristic 2: Files (Workflows usually named {plugin_name}_{command}.*)
        elif item.is_file():
            # Try to match prefix
            matched = False
            for plugin in active_plugins:
                if item.name.startswith(f"{plugin}_"):
                    matched = True
                    break
            
            if not matched:
                # If it doesn't match ANY active plugin prefix, it might be an orphan.
                # BUT, we need to be careful not to delete non-plugin files.
                # We assume bridge_installer uses {plugin_name}_ prefix strict.
                
                # Check if it looks like a plugin artifact (contains underscore)
                if "_" in item.name:
                    possible_plugin = item.name.split("_", 1)[0]
                    # If the prefix IS a valid plugin name format but not in active list
                    # This is hard. 
                    # Simpler: If the file was generated by bridge_installer, it MUST follow pattern.
                    # Let's rely on the prefix check against KNOWN active plugins?
                    # No, that logic serves "Is it valid?". We need "Is it invalid?"
                    
                    # Inverse logic: Does it start with a prefix of a DELETED plugin?
                    # We don't know deleted plugins.
                    
                    # Strategy: 
                    # 1. Start with name. extract prefix.
                    # 2. Is prefix a known active plugin? Yes -> Keep.
                    # 3. No -> Orphan? Maybe.
                    
                    # To be safe, we only delete if we can identify it belongs to a plugin structure.
                    # Most artifacts are {plugin_name}_*.
                    pass
                
                # STRICTER APPROACH:
                # Iterate all items. If item.name starts with {plugin}_ for ANY active plugin, keep it.
                # Else, if it looks like a generated file, flag it.
                # This is risky for users' own files.
                
                # Manifest-less cleanup is hard.
                # Let's try to match against the item name.
                pass

        # REFINED LOGIC:
        # We process items. We check if the item name (or prefix) is present in active_plugins.
        # If it is NOT in active_plugins, AND it looks like a plugin artifact, we delete.
        
        # For Directories (Skills/Rules): exact match expected.
        if item.is_dir():
             if item.name not in active_plugins:
                 # Check if it's a "system" dir? No, these are specific agent dirs.
                 print(f"  [ORPHAN DIR]  {item.name}")
                 if not dry_run:
                     shutil.rmtree(item)

        # For Files (Workflows/Prompts/Toml): prefix match expected.
        elif item.is_file():
             parts = item.name.split('_', 1)
             if len(parts) > 1:
                 potential_plugin = parts[0]
                 # Special case: check if 'potential_plugin' is actually an active plugin
                 if potential_plugin not in active_plugins:
                     # Risk: User created 'my_script.py'. 'my' is not a plugin. Deleted?
                     # Mitigation: Only delete if 'potential_plugin' looks like a plugin we might have had.
                     # Better: Bridge installer strictly namespaces.
                     # If we assume ONLY bridge installer writes here...
                     print(f"  [ORPHAN FILE] {item.name}")
                     if not dry_run:
                         item.unlink()
             else:
                 # No underscore. Bridge installer usually adds underscores.
                 # Exception: Copilot instructions? No, that's a fixed file.
                 pass

def main():
    parser = argparse.ArgumentParser(description="Clean orphaned plugin artifacts.")
    parser.add_argument("--dry-run", action="store_true", help="Print what would be deleted without deleting.")
    args = parser.parse_args()

    root = Path.cwd()
    active_plugins = get_active_plugins(root)
    print(f"Detected {len(active_plugins)} active plugins.")

    for agent, dirs in AGENT_DIRS.items():
        for dir_path in dirs:
            target = root / dir_path
            clean_directory(target, active_plugins, args.dry_run)

    print("Cleanup complete.")

if __name__ == "__main__":
    main()
