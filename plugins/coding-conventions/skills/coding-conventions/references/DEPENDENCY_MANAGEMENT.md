# Dependency Management Guide
**Agent Plugins & Skills Project**

## Overview

This project uses multiple technology stacks that each require dependency management:
- **Python** - Agent plugins, AI skills, and tool integrations (primary focus)
- **Node.js** - UI components, dashboard tools (if applicable)
- **.NET** - Backend services and extensions (if applicable)

## Python Dependency Management

### Core Principles
1.  **Locked Files**: Always use `requirements.txt` files, never manual `pip install`.
2.  **Intent vs. Truth**:
    -   `requirements.in` files = **Human Intent** (what you edit).
    -   `requirements.txt` files = **Machine Truth** (generated by `pip-compile`).
3.  **Consistency**: Same lockfiles used for local development and containers.

### Python Tools in This Project

| Tool | Location | Purpose |
|------|----------|---------|
| **Vector DB Plugin** | `plugins/vector-db/` | Vector database management and retrieval operations |
| **RLM Factory Plugin** | `plugins/rlm-factory/` | Generates RLM configurations and manages AI model tasks |
| **Context Bundler** | `plugins/context-bundler/` | Bundles context for LLMs |

### Adding a Python Dependency

**Step 1: Identify the correct scope**

For Vector DB project:
```bash
# Edit the intent file
vim plugins/vector-db/requirements.in
```

For RLM Factory project:
```bash
# Edit the intent file
vim plugins/rlm-factory/requirements.in
```

**Step 2: Add the package**
```text
# Example: requirements.in
chromadb>=0.4.0
pydantic>=2.0.0
```

**Step 3: Generate lockfile**
```bash
# Generate the locked requirements.txt
pip-compile plugins/vector-db/requirements.in \
  --output-file plugins/vector-db/requirements.txt
```

**Step 4: Install locally**
```bash
# Install from lockfile
pip install -r plugins/vector-db/requirements.txt
```

### Updating Python Dependencies

**DO NOT EDIT `.txt` FILES MANUALLY.**

Update a specific package:
```bash
pip-compile --upgrade-package chromadb plugins/vector-db/requirements.in
```

Update all packages:
```bash
pip-compile --upgrade plugins/vector-db/requirements.in
```

## Node.js Dependency Management

### Core Principles
1.  **Lock is Truth**: `package-lock.json` is the single source of truth. Never ignore it.
2.  **Intent vs. Truth**:
    -   `package.json` = **Human Intent** (semver ranges, e.g., `^18.2.0`).
    -   `package-lock.json` = **Machine Truth** (exact versions, e.g., `18.2.0`).
3.  **Strict Installs**: Use `npm ci` (Clean Install) for reproducible environments.

### Tools Using Node.js

| Tool | Location | Purpose |
|------|----------|---------|
| **Spec-Kitty Dashboard** | `plugins/spec-kitty-dashboard/` | Next.js frontend for spec-kitty data |
| **Example UI** | `plugins/example-ui/` | Web interfaces for specific agent tools |

### Managing Node.js Dependencies

**1. Installing Dependencies (The Standard)**
Use **Clean Install** for setting up projects, CI/CD pipelines, or switching branches.
```bash
npm ci
```
*Why?* Unlike `npm install`, this deletes `node_modules` and installs **exactly** what is in `package-lock.json`. It functions like Python's `pip install -r requirements.txt`.
**Rule:** If `npm ci` fails because `package-lock.json` is out of sync with `package.json`, do NOT force it. Fix the lockfile.

**2. Adding a Dependency (Modifying Intent)**
```bash
cd plugins/spec-kitty-dashboard
npm install <package-name>
# This updates package.json (Intent) AND regenerates package-lock.json (Truth)
```

**3. Updating Dependencies**
```bash
# Update versions within the ranges allowed in package.json
npm update

# For resolving "ERESOLVE" / Peer Dependency issues (Common in Monorepos)
npm install <package-name> --legacy-peer-deps
```

**4. Fixing Lockfile Issues**
If your lockfile gets messy or `npm ci` fails:
```bash
rm -rf node_modules package-lock.json
npm install
# Validate that the only changes are the ones you expect
git diff package-lock.json
```

## .NET Dependency Management

### .NET Projects

| Project | Location | Purpose |
|---------|----------|---------|
| **Example Plugin API** | `plugins/example-api/dotnet/` | Backend extensions for agent APIs |
| **Shared Services** | `plugins/shared-services/dotnet/` | Shared enterprise logic |

### Managing .NET Dependencies

**Adding a NuGet package:**
```bash
cd plugins/example-api/dotnet
dotnet add package EntityFrameworkCore
```

**Updating packages:**
```bash
dotnet restore
dotnet list package --outdated
dotnet add package <PackageName> --version <NewVersion>
```

**Package references:**
All dependencies are tracked in `.csproj` files:
```xml
<ItemGroup>
  <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.0" />
  <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.0" />
</ItemGroup>
```

## Best Practices

### For All Languages

1. **Lock Everything**: Always commit lockfiles (`requirements.txt`, `package-lock.json`, `.csproj`)
2. **Review Updates**: Check breaking changes before upgrading major versions
3. **Security First**: Regularly update dependencies for security patches
4. **Document Constraints**: Note any version constraints in README files

### Version Control

**Always Commit:**
- `requirements.txt` (Python)
- `package-lock.json` (Node.js)
- `*.csproj` files (.NET)

**Never Commit:**
- `node_modules/` (covered by `.gitignore`)
- `bin/`, `obj/` (.NET build outputs)
- `__pycache__/`, `*.pyc` (Python bytecode)
- `venv/`, `.venv/` (Virtual environments)
